/*
<ADT>
1. BFS를 통해 상근이가 각 칸에 도달할 수 있는 최소시간을 표시한다. (= sMap)
2. BFS를 통해 불이 각 칸에 도달할 수 있는 최소 시간을 표시한다. (= fireMap)
3. sMap과 fireMap을 비교하여 상근이가 불보다 빠르게 출구에 도달할 수 있는지를 파악한다.
(이 때, 출구란 가장 바깥쪽의 칸들을 의미한다.)

- Map의 Value 의미
-1 : 벽
0 : 아직 방문하지 않은 칸
n : n 시간만에 방문 가능한 칸
*/

#include <iostream>
#include <queue>
#include <algorithm>
#include <string>

using namespace std;

struct Point {
	int row;
	int col;
};

int rowMax, colMax;
int sMap[1000][1000][2];
int fireMap[1000][1000][2];
int dx[4] = { 1, -1, 0, 0 };
int dy[4] = { 0, 0, 1, -1 };
queue <pair<pair<int, int>, int> >q;

void sMapBfs(int row, int col, int count)
{
	q.push(make_pair(make_pair(row, col), count));

	while (q.size())
	{
		int currentRow = q.front().first.first;			
		int currentCol = q.front().first.second;
		count = q.front().second;
		q.pop();

		sMap[currentRow][currentCol][1] = 1;	// 방문했음을 표시한다.
		sMap[currentRow][currentCol][0] = count++;	// 현재 위치에 올 수 있는 최소경로를 저장한다.

		for (int i = 0; i < 4; i++)
		{
			int nextRow = row + dx[i];
			int nextCol = col + dy[i];

			if (sMap[nextRow][nextCol][1] == 1 || nextRow < 0 || nextRow >= rowMax || nextCol < 0 || nextCol >= colMax)
				continue;

			q.push(make_pair(make_pair(nextRow, nextCol), count));
		}
	}


}

int main()
{
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);

	int testNum;
	cin >> testNum;

	while (testNum)
	{
		string input;
		struct Point firePoint, startPoint;

		cin >> colMax >> rowMax;

		// initialize maps
		for (int i = 0; i < rowMax; i++)
		{
			cin >> input;

			for (int j = 0; j < input.length(); j++)
			{
				if (input[j] == '#')
				{
					sMap[i][j][0] = -1;
					fireMap[i][j][0] = -1;
				}

				else if (input[j] == '*')
				{
					firePoint.row = i;
					firePoint.col = j;
				}

				else if (input[j] == '@')
				{
					startPoint.row = i;
					startPoint.col = j;
				}

				else
				{
					sMap[i][j][0] = 0;
					fireMap[i][j][0] = 0;
				}
			}
		}

		// BFS
		sMapBfs(startPoint.row, startPoint.col, 1);

		for (int i = 0; i < rowMax; i++)
		{
			for (int j = 0; j < colMax; j++)
				cout << sMap[i][j][0] << " ";
			cout << endl;
		}

		// 가장자리 값들 비교해서 탈출 가능 여부 출력

		testNum--;
	}
}
